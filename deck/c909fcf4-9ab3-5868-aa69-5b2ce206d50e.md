---
tags:
- card_type/factual
- debugging/yaml-compilation
- development/materializations
- testing/test-config
citations:
- cleaned_docs/lineage/rank_1.md
guid: 682776bf53
source: llm
uuid: c909fcf4-9ab3-5868-aa69-5b2ce206d50e
claim_meta:
  verdict: SUPPORTED
  explanation: "The reference text explicitly lists three error cases that prevent correct parsing of column-level lineage, directly matching the scenarios in the answer: hardcoding table names triggers an 'Unknown error', Python models cause a 'Python error', and complex SQL patterns like lateral joins lead to 'Parsing errors'."
  citation:
    quote: "Possible error cases are: * **Parsing error** — Error occurs when the SQL is ambiguous or too complex for parsing. An example of ambiguous parsing scenarios are *complex* lateral joins. * **Python error** — Error occurs when a Python model is used within the lineage. * **Unknown error** — Error occurs when the lineage can't be determined for an unknown reason. An example of this would be if a dbt best practice is not being followed, like using hardcoded table names instead of ref statements."
    is_quote_valid: false
---

<front>

What are three common scenarios that prevent dbt from correctly parsing Column-level lineage (CLL)?

</front>

---

<back>

1. Hardcoding table names instead of using `{{ ref() }}` or `{{ source() }}`.
2. Using Python models (which trigger a 'Python error' in CLL views).
3. Complex SQL patterns like lateral joins or JSON unpacking where the column origin is ambiguous.

</back>
