---
tags:
- card_type/factual
- development/python-models
citations:
- cleaned_docs/materializations/rank_4.md
guid: 5de2858a85
source: llm
uuid: aebce78f-d47b-5659-a0bc-d976a13e543f
claim_meta:
  verdict: SUPPORTED
  explanation: "The reference text explicitly supports the answer. It confirms that custom materializations are defined using a syntax similar to `{% materialization [materialization name], [\"specified adapter\" | default] %}` and that dbt selects the implementation based on the current adapter, falling back to 'default' if no adapter-specific version exists, which aligns with the answer's description of multiple dispatch and fallback behavior."
  citation:
    quote: "Materializations are defined as follows:  ``` {% materialization [materialization name], [\"specified adapter\" | default] %}   ...   {% endmaterialization %} ```  Materializations can be given a name, and they can be tied to a specific adapter. dbt will pick the materialization tied to the currently-in-use adapter if one exists, or it will fall back to the `default` adapter."
    is_quote_valid: true
---

<front>

How do you define a custom materialization in dbt, and how does dbt determine which implementation to use?

</front>

---

<back>

You define materializations using the `{% materialization name, adapter %}` block. dbt uses **multiple dispatch** to determine which implementation to use: it looks for an implementation specific to the current adapter (e.g., `adapter='snowflake'`). If none is found, it falls back to the implementation defined with `default`.

</back>
