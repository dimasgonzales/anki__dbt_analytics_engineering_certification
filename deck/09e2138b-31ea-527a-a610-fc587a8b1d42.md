---
tags:
- card_type/factual
- debugging/compiled-code
- development/materializations
- development/seeds
citations:
- cleaned_docs/sql-performance/rank_10.md
guid: 91a1efbc89
source: llm
uuid: 09e2138b-31ea-527a-a610-fc587a8b1d42
claim_meta:
  verdict: SUPPORTED
  explanation: "The reference text explicitly shows the use of the Jinja pattern described in the answer. The code example in cli-commands/rank_3.md directly demonstrates wrapping filter logic in an '{% if is_incremental() %}' block and using the '{{ this }}' variable to query the target table for the maximum timestamp, which prevents full table scans on subsequent runs."
  citation:
    quote: "models/example.sql  ``` select * from all_events    -- if the table already exists and `--full-refresh` is   -- not set, then only add new records. otherwise, select   -- all records.   {% if is_incremental() %}      where collector_tstamp > (        select coalesce(max(max_tstamp), '0001-01-01') from {{ this }}      )   {% endif %} ```"
    is_quote_valid: true
---

<front>

In a dbt incremental model, what is the specific Jinja pattern used to prevent full table scans on subsequent runs?

</front>

---

<back>

You wrap the filter logic within an `{% if is_incremental() %}` block and use the `{{ this }}` variable to reference the existing target table. This allows you to query only rows created after the maximum timestamp in the destination table.

</back>
