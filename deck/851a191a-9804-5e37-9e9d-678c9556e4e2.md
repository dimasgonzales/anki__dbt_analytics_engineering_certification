---
tags:
- card_type/factual
- debugging/compiled-code
- development/cli-commands
- development/python-models
citations:
- cleaned_docs/materializations/rank_4.md
guid: 46d429d89f
source: llm
uuid: 851a191a-9804-5e37-9e9d-678c9556e4e2
claim_meta:
  verdict: SUPPORTED
  explanation: "The answer accurately describes using `run_hooks` for pre- and post-hooks and `adapter.commit()` for transaction commitment, which are explicitly supported by the reference text on custom materializations."
  citation:
    evidence_source: "https://docs.getdbt.com/guides/create-new-materializations"
    quote: "The `run_hooks` function is used to invoke pre- and post-hooks, which are automatically injected into the materialization context. The `adapter.commit()` function is used to commit the transaction opened in the 'preparation' step above."
    is_quote_valid: false
---

<front>

When writing a custom materialization, what three steps are critical for managing the model execution lifecycle correctly?

</front>

---

<back>

1. **Run Pre-hooks**: Execute `{{ run_hooks(pre_hooks) }}` before the main SQL.
2. **Run Post-hooks**: Execute `{{ run_hooks(post_hooks) }}` after the main SQL.
3. **Commit Transaction**: Explicitly call `{{ adapter.commit() }}` at the end to finalize the database changes.

</back>
