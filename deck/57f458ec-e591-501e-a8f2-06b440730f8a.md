---
tags:
- card_type/factual
- debugging/compiled-code
- development/jinja-macros
- development/seeds
citations:
  - docs/site_docs.getdbt.com/citations/docs_getdbt_com_reference_dbt_jinja_functions_dispatch.md
guid: Bd4L!X!XJ2
source: apkg
uuid: 57f458ec-e591-501e-a8f2-06b440730f8a
claim_meta:
  verdict: NOT_FOUND
  explanation: "The reference text does not contain information about the `adapter.dispatch` method or its functionality as described in the answer. It includes general information about Jinja macros and a citation to the dispatch function page, but no details or quotes that verify the specific method signature, usage example, or behavior such as adapter-specific implementations, search criteria, or namespace routing."
  citation:
    quote: null
    is_quote_valid: false
---

<front>

What Jinja `adapter` method enables you to delegate the functionality of a macro interface to any number of adapter-specific implementations?

</front>

---

<back>

```
adapter.dispatch('macro_name', 'optional_macro_namespace')(macro_args)
```Example usage:
```
{% macro my\_macro(arg1, arg2) -%}
{{ return(adapter.dispatch('my\_macro')(arg1, arg2)) }}
{%- endmacro %}
```  
dbt uses two criteria when searching for the right candidate macro to delegate implementation to: adapter prefix (e.g. "snowflake\_\_") and namespace. So, if you define a macro called "concat" whose implementation is just a call to `adapter.dispatch()`, and you are running on Snowflake, dbt will look for a macro called "snowflake\_\_concat" to *actually* call when you call "concat".   
  
By default, dbt will search for macro implementations in the root project and internal projects. However, if the optional `macro_namespace` argument is provided, dbt instead searches the specified namespace/package for implementations. It is also possible to dynamically route namespace searching via the `dispatch` project config option.

</back>
