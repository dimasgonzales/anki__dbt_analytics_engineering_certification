---
uuid: 57f458ec-e591-501e-a8f2-06b440730f8a
guid: Bd4L!X!XJ2
citations:
- https://docs.getdbt.com/reference/dbt-jinja-functions/dispatch
tags:
- jinja-macros
- modularity
- compiled-code
---

<front>

What Jinja `adapter` method enables you to delegate the functionality of a macro interface to any number of adapter-specific implementations?

</front>

---

<back>

```
adapter.dispatch('macro_name', 'optional_macro_namespace')(macro_args)
```Example usage:
```
{% macro my\_macro(arg1, arg2) -%}
{{ return(adapter.dispatch('my\_macro')(arg1, arg2)) }}
{%- endmacro %}
```  
dbt uses two criteria when searching for the right candidate macro to delegate implementation to: adapter prefix (e.g. "snowflake\_\_") and namespace. So, if you define a macro called "concat" whose implementation is just a call to `adapter.dispatch()`, and you are running on Snowflake, dbt will look for a macro called "snowflake\_\_concat" to *actually* call when you call "concat".   
  
By default, dbt will search for macro implementations in the root project and internal projects. However, if the optional `macro_namespace` argument is provided, dbt instead searches the specified namespace/package for implementations. It is also possible to dynamically route namespace searching via the `dispatch` project config option.

</back>
